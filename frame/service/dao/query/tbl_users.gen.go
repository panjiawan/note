// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"FRAME/service/dao/model"
)

func newTblUser(db *gorm.DB, opts ...gen.DOOption) tblUser {
	_tblUser := tblUser{}

	_tblUser.tblUserDo.UseDB(db, opts...)
	_tblUser.tblUserDo.UseModel(&model.TblUser{})

	tableName := _tblUser.tblUserDo.TableName()
	_tblUser.ALL = field.NewAsterisk(tableName)
	_tblUser.UserID = field.NewInt32(tableName, "user_id")
	_tblUser.Email = field.NewString(tableName, "email")
	_tblUser.UserName = field.NewString(tableName, "user_name")
	_tblUser.Password = field.NewString(tableName, "password")
	_tblUser.Question = field.NewString(tableName, "question")
	_tblUser.Answer = field.NewString(tableName, "answer")
	_tblUser.Sex = field.NewInt32(tableName, "sex")
	_tblUser.Birthday = field.NewTime(tableName, "birthday")
	_tblUser.UserMoney = field.NewFloat64(tableName, "user_money")
	_tblUser.FrozenMoney = field.NewFloat64(tableName, "frozen_money")
	_tblUser.PayPoints = field.NewInt32(tableName, "pay_points")
	_tblUser.RankPoints = field.NewInt32(tableName, "rank_points")
	_tblUser.AddressID = field.NewInt32(tableName, "address_id")
	_tblUser.RegTime = field.NewInt32(tableName, "reg_time")
	_tblUser.LastLogin = field.NewInt32(tableName, "last_login")
	_tblUser.LastTime = field.NewTime(tableName, "last_time")
	_tblUser.LastIP = field.NewString(tableName, "last_ip")
	_tblUser.VisitCount = field.NewInt32(tableName, "visit_count")
	_tblUser.UserRank = field.NewInt32(tableName, "user_rank")
	_tblUser.IsSpecial = field.NewInt32(tableName, "is_special")
	_tblUser.EcSalt = field.NewString(tableName, "ec_salt")
	_tblUser.Salt = field.NewString(tableName, "salt")
	_tblUser.ParentID = field.NewInt32(tableName, "parent_id")
	_tblUser.Flag = field.NewInt32(tableName, "flag")
	_tblUser.Alias_ = field.NewString(tableName, "alias")
	_tblUser.Msn = field.NewString(tableName, "msn")
	_tblUser.Qq = field.NewString(tableName, "qq")
	_tblUser.OfficePhone = field.NewString(tableName, "office_phone")
	_tblUser.HomePhone = field.NewString(tableName, "home_phone")
	_tblUser.MobilePhone = field.NewString(tableName, "mobile_phone")
	_tblUser.IsValidated = field.NewInt32(tableName, "is_validated")
	_tblUser.CreditLine = field.NewFloat64(tableName, "credit_line")
	_tblUser.PasswdQuestion = field.NewString(tableName, "passwd_question")
	_tblUser.PasswdAnswer = field.NewString(tableName, "passwd_answer")

	_tblUser.fillFieldMap()

	return _tblUser
}

type tblUser struct {
	tblUserDo

	ALL            field.Asterisk
	UserID         field.Int32
	Email          field.String
	UserName       field.String
	Password       field.String
	Question       field.String
	Answer         field.String
	Sex            field.Int32
	Birthday       field.Time
	UserMoney      field.Float64
	FrozenMoney    field.Float64
	PayPoints      field.Int32
	RankPoints     field.Int32
	AddressID      field.Int32
	RegTime        field.Int32
	LastLogin      field.Int32
	LastTime       field.Time
	LastIP         field.String
	VisitCount     field.Int32
	UserRank       field.Int32
	IsSpecial      field.Int32
	EcSalt         field.String
	Salt           field.String
	ParentID       field.Int32
	Flag           field.Int32
	Alias_         field.String
	Msn            field.String
	Qq             field.String
	OfficePhone    field.String
	HomePhone      field.String
	MobilePhone    field.String
	IsValidated    field.Int32
	CreditLine     field.Float64
	PasswdQuestion field.String
	PasswdAnswer   field.String

	fieldMap map[string]field.Expr
}

func (t tblUser) Table(newTableName string) *tblUser {
	t.tblUserDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tblUser) As(alias string) *tblUser {
	t.tblUserDo.DO = *(t.tblUserDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tblUser) updateTableName(table string) *tblUser {
	t.ALL = field.NewAsterisk(table)
	t.UserID = field.NewInt32(table, "user_id")
	t.Email = field.NewString(table, "email")
	t.UserName = field.NewString(table, "user_name")
	t.Password = field.NewString(table, "password")
	t.Question = field.NewString(table, "question")
	t.Answer = field.NewString(table, "answer")
	t.Sex = field.NewInt32(table, "sex")
	t.Birthday = field.NewTime(table, "birthday")
	t.UserMoney = field.NewFloat64(table, "user_money")
	t.FrozenMoney = field.NewFloat64(table, "frozen_money")
	t.PayPoints = field.NewInt32(table, "pay_points")
	t.RankPoints = field.NewInt32(table, "rank_points")
	t.AddressID = field.NewInt32(table, "address_id")
	t.RegTime = field.NewInt32(table, "reg_time")
	t.LastLogin = field.NewInt32(table, "last_login")
	t.LastTime = field.NewTime(table, "last_time")
	t.LastIP = field.NewString(table, "last_ip")
	t.VisitCount = field.NewInt32(table, "visit_count")
	t.UserRank = field.NewInt32(table, "user_rank")
	t.IsSpecial = field.NewInt32(table, "is_special")
	t.EcSalt = field.NewString(table, "ec_salt")
	t.Salt = field.NewString(table, "salt")
	t.ParentID = field.NewInt32(table, "parent_id")
	t.Flag = field.NewInt32(table, "flag")
	t.Alias_ = field.NewString(table, "alias")
	t.Msn = field.NewString(table, "msn")
	t.Qq = field.NewString(table, "qq")
	t.OfficePhone = field.NewString(table, "office_phone")
	t.HomePhone = field.NewString(table, "home_phone")
	t.MobilePhone = field.NewString(table, "mobile_phone")
	t.IsValidated = field.NewInt32(table, "is_validated")
	t.CreditLine = field.NewFloat64(table, "credit_line")
	t.PasswdQuestion = field.NewString(table, "passwd_question")
	t.PasswdAnswer = field.NewString(table, "passwd_answer")

	t.fillFieldMap()

	return t
}

func (t *tblUser) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tblUser) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 34)
	t.fieldMap["user_id"] = t.UserID
	t.fieldMap["email"] = t.Email
	t.fieldMap["user_name"] = t.UserName
	t.fieldMap["password"] = t.Password
	t.fieldMap["question"] = t.Question
	t.fieldMap["answer"] = t.Answer
	t.fieldMap["sex"] = t.Sex
	t.fieldMap["birthday"] = t.Birthday
	t.fieldMap["user_money"] = t.UserMoney
	t.fieldMap["frozen_money"] = t.FrozenMoney
	t.fieldMap["pay_points"] = t.PayPoints
	t.fieldMap["rank_points"] = t.RankPoints
	t.fieldMap["address_id"] = t.AddressID
	t.fieldMap["reg_time"] = t.RegTime
	t.fieldMap["last_login"] = t.LastLogin
	t.fieldMap["last_time"] = t.LastTime
	t.fieldMap["last_ip"] = t.LastIP
	t.fieldMap["visit_count"] = t.VisitCount
	t.fieldMap["user_rank"] = t.UserRank
	t.fieldMap["is_special"] = t.IsSpecial
	t.fieldMap["ec_salt"] = t.EcSalt
	t.fieldMap["salt"] = t.Salt
	t.fieldMap["parent_id"] = t.ParentID
	t.fieldMap["flag"] = t.Flag
	t.fieldMap["alias"] = t.Alias_
	t.fieldMap["msn"] = t.Msn
	t.fieldMap["qq"] = t.Qq
	t.fieldMap["office_phone"] = t.OfficePhone
	t.fieldMap["home_phone"] = t.HomePhone
	t.fieldMap["mobile_phone"] = t.MobilePhone
	t.fieldMap["is_validated"] = t.IsValidated
	t.fieldMap["credit_line"] = t.CreditLine
	t.fieldMap["passwd_question"] = t.PasswdQuestion
	t.fieldMap["passwd_answer"] = t.PasswdAnswer
}

func (t tblUser) clone(db *gorm.DB) tblUser {
	t.tblUserDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tblUser) replaceDB(db *gorm.DB) tblUser {
	t.tblUserDo.ReplaceDB(db)
	return t
}

type tblUserDo struct{ gen.DO }

type ITblUserDo interface {
	gen.SubQuery
	Debug() ITblUserDo
	WithContext(ctx context.Context) ITblUserDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITblUserDo
	WriteDB() ITblUserDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITblUserDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITblUserDo
	Not(conds ...gen.Condition) ITblUserDo
	Or(conds ...gen.Condition) ITblUserDo
	Select(conds ...field.Expr) ITblUserDo
	Where(conds ...gen.Condition) ITblUserDo
	Order(conds ...field.Expr) ITblUserDo
	Distinct(cols ...field.Expr) ITblUserDo
	Omit(cols ...field.Expr) ITblUserDo
	Join(table schema.Tabler, on ...field.Expr) ITblUserDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITblUserDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITblUserDo
	Group(cols ...field.Expr) ITblUserDo
	Having(conds ...gen.Condition) ITblUserDo
	Limit(limit int) ITblUserDo
	Offset(offset int) ITblUserDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITblUserDo
	Unscoped() ITblUserDo
	Create(values ...*model.TblUser) error
	CreateInBatches(values []*model.TblUser, batchSize int) error
	Save(values ...*model.TblUser) error
	First() (*model.TblUser, error)
	Take() (*model.TblUser, error)
	Last() (*model.TblUser, error)
	Find() ([]*model.TblUser, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TblUser, err error)
	FindInBatches(result *[]*model.TblUser, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TblUser) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITblUserDo
	Assign(attrs ...field.AssignExpr) ITblUserDo
	Joins(fields ...field.RelationField) ITblUserDo
	Preload(fields ...field.RelationField) ITblUserDo
	FirstOrInit() (*model.TblUser, error)
	FirstOrCreate() (*model.TblUser, error)
	FindByPage(offset int, limit int) (result []*model.TblUser, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITblUserDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tblUserDo) Debug() ITblUserDo {
	return t.withDO(t.DO.Debug())
}

func (t tblUserDo) WithContext(ctx context.Context) ITblUserDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tblUserDo) ReadDB() ITblUserDo {
	return t.Clauses(dbresolver.Read)
}

func (t tblUserDo) WriteDB() ITblUserDo {
	return t.Clauses(dbresolver.Write)
}

func (t tblUserDo) Session(config *gorm.Session) ITblUserDo {
	return t.withDO(t.DO.Session(config))
}

func (t tblUserDo) Clauses(conds ...clause.Expression) ITblUserDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tblUserDo) Returning(value interface{}, columns ...string) ITblUserDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tblUserDo) Not(conds ...gen.Condition) ITblUserDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tblUserDo) Or(conds ...gen.Condition) ITblUserDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tblUserDo) Select(conds ...field.Expr) ITblUserDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tblUserDo) Where(conds ...gen.Condition) ITblUserDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tblUserDo) Order(conds ...field.Expr) ITblUserDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tblUserDo) Distinct(cols ...field.Expr) ITblUserDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tblUserDo) Omit(cols ...field.Expr) ITblUserDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tblUserDo) Join(table schema.Tabler, on ...field.Expr) ITblUserDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tblUserDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITblUserDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tblUserDo) RightJoin(table schema.Tabler, on ...field.Expr) ITblUserDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tblUserDo) Group(cols ...field.Expr) ITblUserDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tblUserDo) Having(conds ...gen.Condition) ITblUserDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tblUserDo) Limit(limit int) ITblUserDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tblUserDo) Offset(offset int) ITblUserDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tblUserDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITblUserDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tblUserDo) Unscoped() ITblUserDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tblUserDo) Create(values ...*model.TblUser) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tblUserDo) CreateInBatches(values []*model.TblUser, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tblUserDo) Save(values ...*model.TblUser) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tblUserDo) First() (*model.TblUser, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TblUser), nil
	}
}

func (t tblUserDo) Take() (*model.TblUser, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TblUser), nil
	}
}

func (t tblUserDo) Last() (*model.TblUser, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TblUser), nil
	}
}

func (t tblUserDo) Find() ([]*model.TblUser, error) {
	result, err := t.DO.Find()
	return result.([]*model.TblUser), err
}

func (t tblUserDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TblUser, err error) {
	buf := make([]*model.TblUser, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tblUserDo) FindInBatches(result *[]*model.TblUser, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tblUserDo) Attrs(attrs ...field.AssignExpr) ITblUserDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tblUserDo) Assign(attrs ...field.AssignExpr) ITblUserDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tblUserDo) Joins(fields ...field.RelationField) ITblUserDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tblUserDo) Preload(fields ...field.RelationField) ITblUserDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tblUserDo) FirstOrInit() (*model.TblUser, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TblUser), nil
	}
}

func (t tblUserDo) FirstOrCreate() (*model.TblUser, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TblUser), nil
	}
}

func (t tblUserDo) FindByPage(offset int, limit int) (result []*model.TblUser, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tblUserDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tblUserDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tblUserDo) Delete(models ...*model.TblUser) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tblUserDo) withDO(do gen.Dao) *tblUserDo {
	t.DO = *do.(*gen.DO)
	return t
}
